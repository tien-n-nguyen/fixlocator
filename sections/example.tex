\section{Motivating Example}
\label{motiv:section}

\subsection{Example and Observations}

\begin{figure}[t]
	\centering
	\lstset{
		numbers=left,
		numberstyle= \tiny,
		keywordstyle= \color{blue!70},
		commentstyle= \color{red!50!green!50!blue!50},
		frame=shadowbox,
		rulesepcolor= \color{red!20!green!20!blue!20} ,
		xleftmargin=1.5em,xrightmargin=0em, aboveskip=1em,
		framexleftmargin=1.5em,
                numbersep= 5pt,
		language=Java,
    basicstyle=\scriptsize\ttfamily,
    numberstyle=\scriptsize\ttfamily,
    emphstyle=\bfseries,
                moredelim=**[is][\color{red}]{@}{@},
		escapeinside= {(*@}{@*)}
	}
	\begin{lstlisting}[]
public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {
	......
(*@{\color{red}{-	String code = toSource(root, sourceMap);}@*)
(*@{\color{cyan}{+	String code = toSource(root, sourceMap, inputSeqNum == 0);}@*)
	if (!code.isEmpty()) {
		cb.append(code);
	}
	......
}
//--------------------------------------------------------------------------
(*@@Override@*)
String toSource(Node n) {
	initCompilerOptionsIfTesting();
(*@{\color{red}{-	return toSource(n, null);}@*)
(*@{\color{cyan}{+ 	return toSource(n, null, true);}@*)
}
//--------------------------------------------------------------------------
(*@{\color{red}{- private String toSource(Node n, SourceMap sourceMap) {}@*)
(*@{\color{cyan}{+ private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {}@*)
	......
  builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);
(*@{\color{red}{-   builder.setTagAsStrict(}@*)
(*@{\color{cyan}{+   builder.setTagAsStrict(firstOutput}@*) && 
		options.getLanguageOut(a) == LanguageMode.ECMASCRIPT5_STRICT);
  builder.setLineLengthThreshold(options.lineLengthThreshold);
	......	
}	
	\end{lstlisting}
        \vspace{-15pt}
        \caption{A Multi-statement/Multi-method Bug Fix}
        \vspace{-6pt}
        \label{fig:motiv}
\end{figure}

Let us start with a real-world example on the kind of bug fixes that
require multiple changes to multiple statements in different methods.
Figure~\ref{fig:motiv} shows a bug in Defects4J dataset. The bug
occurred when the method call to \code{setTagAsStrict} did not
consider the first output in its arguments. Therefore, to fix it, a
developer adds a new argument in the method \code{toSource} at line
19, and uses that argument in the method call \code{setTagAsStrict
  (firstOutput,...)} at line 23. Because the method \code{toSource} at
line 19 was changed, the two callers at line 3 of the method
\code{toSource} (line 1) and at line 14 of the method \code{toSource}
(line 12) need to be changed accordingly.

%This is a bug from Defects4J data that has three methods need to be fixed at the same time. The bug is caused by doing the method call $setTagAsStrict$ without checking if it is the first output. To fix this bug, firstly, for the method C, we need to add one more parameter $firstOutput$ for the method call $setTagAsStrict$. Then, for the method A and B, because they call the method C or override the method C, when adding a new parameter in the method C, they all need to do the same thing. We need to add $inputSeqNum == 0$ in method A and add $true$ in method B when calling the method C.

%In this bug, there are multiple statements that need to be fixed and they located in three different methods. Also, when analyzing the co-change information, the method A and method C have been fixed together before in the commit history. 

\noindent {\bf Observation 1. [Co-Change Fixing Locations]} As seen in
this example, the changes to fix this bug involve multiple buggy
statements and dependent on one another. Fixing one of the buggy
statements will not make the program pass the previously failing
test(s). For an APR model to work, an FL tool needs to point out all
of those buggy statements to be changed in the same fix. For effective
fixing by developers, an FL tool also needs point out all the buggy
statements to be fixed at once. Otherwise, (s)he must find
the missing locations or waste time with incorrect ones.

\noindent {\bf Observation 2. [Multiple Buggy Methods]} As seen, this
bug requires the changes to three different methods at the same time.
It is important for an FL tool to connect and identify these multiple
buggy statements in potentially different methods.

Traditional FL approaches~\cite{zhang-fse09} using program analysis (PA), e.g.,
program slicing, could identify all of those statements in the same
fix due to their caller/callee
relations. Spectrum-based~\cite{tarantula05,Ochiai},
mutation-based~\cite{MUSE,papadakis2012using,Metallaxis}),
statistic-based~\cite{liblit-pldi05}, and machine-learning-based FL
approaches~\cite{DeepFL,icse21-fl} could implicitly learn the program
dependences for FL. However, despite their successes, the non-PA FL
approaches {\em do not support the detection of multiple locations
  that need to be changed in the same fix for a bug, i.e., Co-Change
  Fixing Locations} (CC Fixing Locations).
%
All of the spectrum-based and ML-based FL models return a ranked list
of suspicious statements according to the corresponding suspiciousness
scores. In this example, the lines 3, 14, 19, 22, and the other lines
({\em e.g.}, 5, 13, 21 and 25) are executed in the same passing or
failing test cases, thus, are assigned the same scores by
spectrum-based and mutation-based FL approaches. A developer would not
be informed on what lines need to be fixed together. The
statistics-based ML-based FL approaches do not have any mechanism to
detect CC Fixing Locations.

Detecting CC Fixing Locations is challenging. A solution of assuming
the top-$k$ suspicious statements from a FL tool as CC fixing
locations does not work because those lines are top suspicious, yet
might not be needed to be changed in the same fix. In this example,
all of the above lines with the same suspiciousness scores would
confuse a fixer. Moreover, another naive solution would be to
detect multiple buggy methods first and then use an existing FL tool
to detect the lines within each buggy method. As we will show in our
experiment, the inaccuracy of the first phase will have a confounding
effect in the overall performance of such a FL tool.


