\subsubsection{{\bf Illustrating Example}}
\label{sec:example}

\begin{figure}[t]
	\centering
	\lstset{
		numbers=left,
		numberstyle= \tiny,
		keywordstyle= \color{blue!70},
		commentstyle= \color{red!50!green!50!blue!50},
		frame=shadowbox,
		rulesepcolor= \color{red!20!green!20!blue!20} ,
		xleftmargin=1.5em,xrightmargin=0em, aboveskip=1em,
		framexleftmargin=1.5em,
		numbersep= 5pt,
		language=Java,
		basicstyle=\scriptsize\ttfamily,
		numberstyle=\scriptsize\ttfamily,
		emphstyle=\bfseries,
		moredelim=**[is][\color{red}]{@}{@},
		escapeinside= {(*@}{@*)}
	}
	\begin{lstlisting}[]
public UnivariateRealPointValuePair optimize(final FUNC f, GoalType goal, double min, double max) throws FunctionEvaluationException {
(*@{\color{red}{  - return optimize(f, goal, min, max, 0);@*)
(*@{\color{cyan}{  + return optimize(f, goal, min, max, min + 0.5 * (max - min));@*)
}
public UnivariateRealPointValuePair optimize(final FUNC f, GoalType goal, double min, double max, double startValue) throws Func...Exception {
       ...
       try {
(*@{\color{red}{-        final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);@*)
(*@{\color{red}{-        final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);@*)
(*@{\color{red}{-        optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));@*)
(*@{\color{cyan}{+       final double s = (i == 0) ? startValue : min + generator.nextDouble() * (max - min);@*)
(*@{\color{cyan}{+       optima[i] = optimizer.optimize(f, goal, min, max, s);@*)
   ...
}
\end{lstlisting}
        \vspace{-15pt}
	\caption{An Illustrating Example}
	\label{example}
\end{figure}

Figure~\ref{example} shows an example in our dataset that {\tool}
correctly identified all {\em four CC fixing statements} in its predicted
set (lines 2, 8, 9, and 10 in two methods) that need to be fixed
together (CC fixing locations).

The statement-only model detects only line 2 as faulty. It completely
missed lines 8--10 of the \code{optimize} method (line 5). In contrast,
the cascading model detects lines 8--10, however, its \code{MethFL}
considers the first method (\code{optimize(...)} at line 1) as
non-faulty, thus, it did not detect the buggy line 2 due
to its cascading architecture.

% Table generated by Excel2LaTeX from sheet 'Sheet1'
\begin{table}[t]
  \centering
  \caption{Ranking of CC Fixing Locations for Figure~\ref{example}}
  \vspace{-9pt}
  {\footnotesize
    \begin{tabular}{|lcccc|}
    \toprule
     {\textbf{Locs}} & \multicolumn{1}{l} {\textbf{CNN-FL}} & \multicolumn{1}{l}{\textbf{DeepFL}} & \multicolumn{1}{l}{\textbf{DeepRL4FL}} & \multicolumn{1}{l|}{\textbf{FixLocator}} \\
    \midrule
    Line 2 & {\bf 1}     & 22    & {\bf 2}     & {\bf 1} \\
    \midrule
    Line 8 & 24    & {\bf 3}     & 6     & {\bf 3} \\
    \midrule
    Line 9 & 25    & {\bf 4}     & 7     & {\bf 4} \\
    \midrule
    Line 10 & 50+    & 13    & 16    & {\bf 2} \\
    \bottomrule
    \end{tabular}%
  \label{tab:ranking}%
  }
\end{table}%

Table~\ref{tab:ranking} displays the ranking from the models for the
faulty statements in the example. {\tool} correctly predicted {\em the set
of those four CC fixing statements} and ranked them at the top 4
positions. CCN-FL, DeepFL, and DeepRL4FL detect only 1, 2, and 1
faulty statements (bold cells) in their top-4 resulting lists,
respectively. The top-4 resulting list from CNN-FL is [2, X, X, X] (X
is the line number in other clean methods not shown in
Figure~\ref{example}); the list from DeepFL is [X, X, 8, 9]; and that
from DeepRL4FL is [X, 2, X, 169 of \code{optimize}]. In brief, the
baselines are not designed to detect CC fixing locations, thus,
their top-$K$ lists are not~correct.
